# 算法
## mayer键级的拆分
密度矩阵的公式为

$$
P_{\mu \nu }=\eta_i \sum _{i}C_{\mu i}C_{\nu i}
$$

可以看出总的密度矩阵是每一个分子轨道对应的密度矩阵之和，即：

$$
P=\sum _{i}P_i
$$

键级的公式为：

$$
P_{ab}=|\sum_{a \in A}\sum_{b \in B}(PS)_{ab}(PS)_{ba}|^{1/2}
$$

这是一个双重求和，可以以矩阵运算的形式表示（方便计算机运算）：

$$
P_{ab}=sum[(PS)_{ab}\times (PS)_{ba}]
$$

假设现在只有一个原子，并且这个原子有三个轨道，那么

$$
PS=(P_1+P_2+P_3)@S
$$

$$
P_{ab}=(PS)^2=[(P_1+P_2+P_3)@S]^2=(P_1+P_2+P_3)^2@S^2
$$

累加的平方可以用矩阵形式来表达：

| | $P_1$ | $P_2$ | $P_3$ |
| ----  | --------- | --------- | --------- |
| $P_1$ | $P_{1}P_{1}$ | $P_{1}P_{2}$ | $P_{1}P_{3}$ |
| $P_2$ | $P_{2}P_{1}$ | $P_{2}P_{2}$ | $P_{2}P_{3}$ |
| $P_3$ | $P_{3}P_{1}$ | $P_{3}P_{2}$ | $P_{3}P_{3}$ |

其中的每一项再乘上重叠矩阵的平法即为键级矩阵，其大小与分子轨道数量一致，也是一个对称矩阵，对其行或列求和可得每一个分子轨道的键级，对于多原子和多轨道可用相似的方法，详情可查看源代码

这样就把Mayer键级中的每一个分子轨道键级都拆出来啦哈哈哈 >_<

后记：

虽然这样算出来对应的是每一个分子轨道的键级，但是其加和并不等于最终的键级，例如最终的键级为：

$$
P=\sqrt{|a+b+c|}
$$

而我们现在知道的是a,b,c，如何求出这三个数在最终键级里所占的比例呢？  
目前能想到的就是a,b,c分别除他们的和了，相加为1，有正有负，算是比例，再乘上总键级，即：

$$
P_i=\frac{i}{a+b+c}\times \sqrt{|a+b+c|}
$$

其中$i\in (a,b,c)$，三个键级相加正好等于1

## 矩阵乘法构建密度矩阵
密度矩阵的公式为：

$$
P_{\mu \nu }=\eta_i \sum _{i}C_{\mu i}C_{\nu i}
$$

原来的计算方法很形象，即为逐元素构建矩阵元
```python
l,c=CM.shape
PMs=np.zeros(shape=(c,l,l)) #[n,n,n] 三维矩阵，第0个维度是分子轨道的序数
for j in range(c):
    ci=CM[:,j].reshape(-1,1) #[n,1]
    cj=CM[:,j].reshape(1,-1) #[1,n]
    e=n[j]
    PMs[j,:,:]=ci@cj*e
```
但是这种方法计算速度很慢，而现在我摸索出了用矩阵乘法计算的方式
```python
A=(CM.copy().T)[:,:,np.newaxis]
B=(CM.copy().T)[:,np.newaxis,:]
PMs=A@B
```
可以看出，形式非常简洁，相当于一个`[3,3,1]`的矩阵和一个`[3,1,3]`的矩阵相乘，三维矩阵的乘法本质上还是最后两个维度的矩阵相乘，再把结果堆叠在一起。

经测试联苯，计算速度提升了有70倍！而且越是大的分子计算速度提升的越明显

## 减小内存开销
今天在师姐那程序遇到了一个问题
```shell
numpy.core._exceptions.MemoryError: Unable to allocate 11.6 GiB for an array with shape (1838, 919, 919) and data type float64
```
可以看到，程序在构建密度矩阵的时候构建了一个1838个分子轨道的三维矩阵
，numpy数组太大了，占用内存太多了，所以报错。为了减小内存开销，有以下几个解决策略：  
1. 减小数据进度，使用`float32`八位小数就够了
2. 不计算空轨道，空轨道数量很多又没啥用，构建矩阵的时候想办法抛去
3. 构建键级矩阵元的时候，对称矩阵只构建一半，剩下的一半自动生成